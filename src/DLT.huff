/// @title DLT
/// @notice SPDX-License-Identifier: MIT
/// @author zakrad <https://github.com/zakrad>
/// @notice Gas efficient Dual Layer Token implementation

// Errors
#define error Error(string)
#define error Panic(uint256)


/* Function Interface */
#define function mint(address,uint256,uint256,uint256,bytes) nonpayable returns ()
#define function burn(address,uint256,uint256,uint256) nonpayable returns ()

#define function isApprovedForAll(address,address) view returns (bool)
#define function setApprovalForAll(address,bool) nonpayable returns ()

#define function safeTransferFrom(address,address,uint256,uint256,uint256,bytes) nonpayable returns ()

#define function subBalanceOf(address,uint256,uint256) view returns (uint256)

#define function name() view returns (string)
#define function symbol() view returns (string)

/* Events */
#define event Transfer(address,address,address,uint256,uint256,uint256)
#define event TransferBatch(address,address,address,uint256[],uint256[],uint256[])
#define event Approval(address,address,uint256,uint256,uint256)
#define event ApprovalForAll(address,address,bool)
#define event URI(string,string,uint256)

/* Storage Slots */
#define constant NAME_LOCATION = FREE_STORAGE_POINTER()
#define constant SYMBOL_LOCATION = FREE_STORAGE_POINTER()
#define constant SUB_BALANCE_LOCATION = FREE_STORAGE_POINTER()
#define constant IS_APPROVED_FOR_ALL_LOCATION = FREE_STORAGE_POINTER()
#define constant ALLOWANCE_LOCATION = FREE_STORAGE_POINTER()
// Constants
// Solidity Panic Codes
#define constant ARITHMETIC_OVERFLOW = 0x11;

// "NON_PAYABLE" Revert Message String
#define constant NON_PAYABLE_ERROR = 0x4e4f4e5f50415941424c45000000000000000000000000000000000000000000
#define constant NON_PAYABLE_LENGTH = 0x0b

/* Metadata */
// META_NAME = "DualLayerToken"
#define constant META_NAME = 0x4475616c4c61796572546f6b656e000000000000000000000000000000000000
#define constant META_NAME_LENGTH = 0x0e

// META_SYMBOL = "DLT"
#define constant META_SYMBOL = 0x444c540000000000000000000000000000000000000000000000000000000000
#define constant META_SYMBOL_LENGTH = 0x03

// Viewable Function Macros

/// @title Sub Balance Of
/// @notice Entry point for: subBalanceOf(address,uint256,uint256)
/// @dev Slices account and address from calldata and retreives the balance
/// @param {calldata} [address account, uint256 mainId, uint256 subId]
/// @return {return} [uint256 subBalance]
#define macro SUB_BALANCE_OF() = takes (0) returns(0) {
    NON_PAYABLE()
    0x44 calldataload                               // [subId]
    0x24 calldataload                               // [mainId, subId]
    0x04 calldataload                               // [account, mainid, subId]

    GET_SUB_BALANCE_SLOT(0x00)                      // [slot]
    sload                                           // [balance]
    0x00 mstore                                     // [] load into mem
    0x20 0x00 return                                // [] return 32 bytes
}

/// @title Name
/// @notice Returns the name of the contract
/// @param []
/// @return {return} [string]
#define macro NAME() = takes (0) returns (0) {
    NON_PAYABLE()
    0x20 0x00 mstore                    // []
    [META_NAME_LENGTH] 0x20 mstore      // []
    [META_NAME] 0x40 mstore             // []
    0x60 0x00 return                    // []
}

/// @title Symbol
/// @notice Gets the symbol of the contract
/// @param []
/// @return {return} [string]
#define macro SYMBOL() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    0x20 0x00 mstore                    // []
    [META_SYMBOL_LENGTH] 0x20 mstore    // []
    [META_SYMBOL] 0x40 mstore           // []
    0x60 0x00 return                    // []
}



// Helper Macros
// NOTE: Execution flow does not need to stop at the end of these macros

/// @title Get Sub Balance Of
/// @notice Get the balance of a token sub id for a given main id and account.
/// @dev Uses a 2 level nested mapping for getting values 
/// @param {stack} [account, mainId, subId]
/// @return {stack} [balance]
#define macro GET_SUB_BALANCE_SLOT(mem_ptr) = takes (3) returns (1) {
    // input stack: [account, mainId, subId]
    [SUB_BALANCE_LOCATION]            // [SUB_BALANCE_LOCATION, account, mainId, subId]
    <mem_ptr> 0x20 add                // [<mem_ptr> + 32, SUB_BALANCE_LOCATION, account, mainId, subId]
    mstore                            // [account, mainId, subId]
    <mem_ptr> swap1 dup2              // [<mem_ptr>, account, <mem_ptr>, mainId, subId]
    mstore                            // [<mem_ptr>, mainId, subId]
    0x40 dup2                         // [<mem_ptr>, 0x40, <mem_ptr>, mainId, subId]
    sha3                              // [slot1, <mem_ptr>, mainId, subId]

    //concat mainId
    dup2 0x20 add                     // [<mem_ptr> +32, slot1, <mem_ptr>, mainId, subId]
    mstore                            // [<mem_ptr>, mainId, subId]
    swap1 dup2                        // [<mem_ptr>, mainId, <mem_ptr>, subId]
    mstore                            // [<mem_ptr>, subId]
    0x40 dup2                         // [<mem_ptr>, 0x40, <mem_ptr>, subId] 
    sha3                              // [slot2, <mem_ptr>, subId] 

    //concat subId
    dup2 0x20 add                     // [<mem_ptr> +32, slot2, <mem_ptr>, subId]
    mstore                            // [<mem_ptr>, subId]
    swap1 dup2                        // [<mem_ptr>, subId, <mem_ptr>]
    mstore                            // [<mem_ptr>]
    0x40 swap1                        // [<mem_ptr>, 0x40]
    sha3                              // [slot3] 
}

/// @title Decrease Sub Id Balance
/// @notice Decreases the balance by amount of a given account for the given mianId and subId
/// @param {stack} [address from, uint256 mainId, uint256 subId, uint256 amount]
/// @return []
#define macro DECREASE_BALANCE() = takes (4) returns (0) {
    // takes 3 [from, mainId, subId, amount]

    GET_SUB_BALANCE_SLOT(0x00)      // [slot, amount]
    dup1                            // [slot,slot,amount]
    sload                           // [bal, slot, amount]
    swap1                           // [slot, bal, amount]
    swap2                           // [amount, bal, slot]
    swap1                           // [bal, amount, slot]

    // Safe sub balance to revert on underflow
    SAFE_SUB()                      // [(bal-amount), slot]

    // Store decreased balance
    swap1                           // [slot, (bal-amount)]
    sstore                          // []
}

/// @notice Subtracts two numbers and reverts on underflow
#define macro SAFE_SUB() = takes (2) returns (1) {
    // input stack          // [num1, num2]
    dup1                    // [num1, num1, num2]
    dup3                    // [num2, num1, num1, num2]
    gt                      // [is_underflow, num1, num2]
    iszero                  // [is_not_underflow, num1, num2]
    is_not_underflow jumpi  // [num1, num2]
        [ARITHMETIC_OVERFLOW] PANIC()
    is_not_underflow:       // [num1, num2]
    sub                     // [result]
}

/*

Solidity Panic.

MEMORY LAYOUT WHEN THROWN
| sig     || panic code                                                     |
0x4e487b71  0000000000000000000000000000000000000000000000000000000000000001

*/
#define macro PANIC() = takes (1) returns (0) {
    // takes:       // [panic_code]
    __ERROR(Panic)  // [panic_sig, panic_code]
    0x00            // [panic_sig_offset, panic_sig, panic_code]
    mstore          // [panic_code]
    0x04            // [panic_code_offset, panic_code]
    mstore          // []
    0x24            // [revert_size]
    0x00            // [revert_offset, revert_size]
    revert          // []
}

/*

Solidity Require. Error `string` MUST be no greater than 32 bytes.

MEMORY LAYOUT WHEN THROWN
| sig    || message offset                                                 || message length                                                 || message "revert"                                               |
0x08c379a  0000000000000000000000000000000000000000000000000000000000000020  0000000000000000000000000000000000000000000000000000000000000006  7265766572740000000000000000000000000000000000000000000000000000

*/
#define macro REQUIRE() = takes (3) returns (0) {
    // takes:       // [condition, message_length, message]
    do_not_throw    // [do_not_throw_jumpdest, condition, message_length, message]
    jumpi           // [message_length, message]
    __ERROR(Error)  // [error_sig, , message_length, message]
    0x00            // [mem_ptr, error_sig, message_length, message]
    mstore          // [message_length, message]
    0x20            // [message_offset, message_length, message]
    0x04            // [message_offset_ptr, message_offset, message_length, message]
    mstore          // [message_length, message]
    0x24            // [message_length_ptr, message_length, message]
    mstore          // [message]
    0x44            // [message_ptr, message]
    mstore          // []
    0x80            // [size]
    0x00            // [offset, size]
    revert          // []
    do_not_throw:   // [message_length, message]
        pop         // [message]
        pop         // []
}

/// @notice Reverts if the call has a non-zero value
/// @notice Reverts with message "NON_PAYABLE"
#define macro NON_PAYABLE() = takes (0) returns (0) {
    [NON_PAYABLE_ERROR]      // ["NON_PAYABLE"]
    [NON_PAYABLE_LENGTH]     // [11 (length), "NON_PAYABLE"]
    callvalue iszero         // [msg.value == 0, 11 (length), "NON_PAYABLE"]
    REQUIRE()                // []
}


/* Methods */
#define macro SET_VALUE() = takes (0) returns (0) {
    0x04 calldataload   // [value]
    [VALUE_LOCATION]    // [ptr, value]
    sstore              // []
}

#define macro GET_VALUE() = takes (0) returns (0) {
    // Load value from storage.
    [VALUE_LOCATION]   // [ptr]
    sload                // [value]

    // Store value in memory.
    0x00 mstore

    // Return value
    0x20 0x00 return
}

#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 0xE0 shr
    dup1 __FUNC_SIG(setValue) eq set jumpi
    dup1 __FUNC_SIG(getValue) eq get jumpi

    0x00 0x00 revert

    set:
        SET_VALUE()
    get:
        GET_VALUE()

}